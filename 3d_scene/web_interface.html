<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Multi-Camera Scene Viewer</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&family=Space+Grotesk:wght@300;400;500;600&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg-primary: #0a0a0f;
        --bg-secondary: #12121a;
        --bg-tertiary: #1a1a25;
        --accent-cyan: #00d4ff;
        --accent-magenta: #ff00aa;
        --accent-green: #00ff88;
        --text-primary: #ffffff;
        --text-secondary: #8888aa;
        --text-muted: #555566;
        --border-color: #2a2a3a;
      }

      body {
        font-family: "Space Grotesk", sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        min-height: 100vh;
        overflow: hidden;
      }

      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      canvas {
        display: block;
      }

      /* Header overlay */
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 20px 30px;
        background: linear-gradient(
          180deg,
          rgba(10, 10, 15, 0.95) 0%,
          rgba(10, 10, 15, 0) 100%
        );
        z-index: 100;
        display: flex;
        justify-content: space-between;
        align-items: center;
        pointer-events: none;
      }

      .header > * {
        pointer-events: auto;
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .logo-icon {
        width: 36px;
        height: 36px;
        background: linear-gradient(
          135deg,
          var(--accent-cyan),
          var(--accent-magenta)
        );
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 14px;
      }

      .logo h1 {
        font-size: 1.1em;
        font-weight: 500;
        letter-spacing: -0.5px;
      }

      .logo h1 span {
        color: var(--accent-cyan);
      }

      .status-badge {
        display: flex;
        align-items: center;
        gap: 8px;
        background: var(--bg-tertiary);
        padding: 8px 16px;
        border-radius: 20px;
        border: 1px solid var(--border-color);
        font-size: 0.85em;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-muted);
      }

      .status-dot.active {
        background: var(--accent-green);
        box-shadow: 0 0 10px var(--accent-green);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      /* Control panel */
      .control-panel {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(18, 18, 26, 0.95);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 20px;
        z-index: 100;
        min-width: 280px;
        backdrop-filter: blur(20px);
      }

      .panel-title {
        font-size: 0.75em;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: var(--text-secondary);
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--border-color);
      }

      .control-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .control-row:last-child {
        margin-bottom: 0;
      }

      .control-label {
        font-size: 0.9em;
        color: var(--text-secondary);
      }

      .control-value {
        font-family: "JetBrains Mono", monospace;
        font-size: 0.85em;
        color: var(--accent-cyan);
      }

      /* Camera list panel */
      .camera-panel {
        position: fixed;
        top: 80px;
        right: 20px;
        background: rgba(18, 18, 26, 0.95);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 20px;
        z-index: 100;
        max-width: 260px;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        backdrop-filter: blur(20px);
      }

      .camera-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 12px;
        margin-bottom: 8px;
        background: var(--bg-primary);
        border-radius: 8px;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .camera-item:hover {
        border-color: var(--accent-cyan);
        background: rgba(0, 212, 255, 0.05);
      }

      .camera-item.selected {
        border-color: var(--accent-magenta);
        background: rgba(255, 0, 170, 0.1);
      }

      .camera-color {
        width: 12px;
        height: 12px;
        border-radius: 3px;
      }

      .camera-info {
        flex: 1;
      }

      .camera-id {
        font-family: "JetBrains Mono", monospace;
        font-size: 0.85em;
        color: var(--text-primary);
      }

      .camera-number {
        font-size: 0.75em;
        color: var(--text-muted);
      }

      /* Buttons */
      .btn {
        padding: 10px 20px;
        font-size: 0.85em;
        font-weight: 500;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: "Space Grotesk", sans-serif;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .btn-primary {
        background: linear-gradient(
          135deg,
          var(--accent-cyan),
          var(--accent-magenta)
        );
        border: none;
        color: white;
      }

      .btn-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
      }

      .btn-secondary {
        background: transparent;
        color: var(--text-secondary);
      }

      .btn-secondary:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
      }

      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }

      /* Loading overlay */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--bg-primary);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity 0.5s ease;
      }

      .loading-overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .loader {
        width: 60px;
        height: 60px;
        border: 3px solid var(--bg-tertiary);
        border-top-color: var(--accent-cyan);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        margin-top: 20px;
        color: var(--text-secondary);
        font-size: 0.9em;
      }

      /* Instructions */
      .instructions {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(18, 18, 26, 0.95);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 15px 20px;
        z-index: 100;
        backdrop-filter: blur(20px);
      }

      .instruction-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
        font-size: 0.8em;
        color: var(--text-secondary);
      }

      .instruction-item:last-child {
        margin-bottom: 0;
      }

      .key {
        background: var(--bg-tertiary);
        padding: 4px 8px;
        border-radius: 4px;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.9em;
        color: var(--text-primary);
        min-width: 60px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <!-- Loading overlay -->
    <div class="loading-overlay" id="loading">
      <div class="loader"></div>
      <div class="loading-text">Initializing 3D Scene...</div>
    </div>

    <!-- Three.js canvas -->
    <div id="canvas-container"></div>

    <!-- Header -->
    <div class="header">
      <div class="logo">
        <div class="logo-icon">3D</div>
        <h1>Multi-Camera <span>Scene Viewer</span></h1>
      </div>
      <div class="status-badge">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Connecting...</span>
      </div>
    </div>

    <!-- Control panel -->
    <div class="control-panel">
      <div class="panel-title">Scene Controls</div>
      <div class="control-row">
        <span class="control-label">Cameras</span>
        <span class="control-value" id="cameraCount">0</span>
      </div>
      <div class="control-row">
        <span class="control-label">Frame Rate</span>
        <span class="control-value" id="frameRate">--</span>
      </div>
      <div class="control-row">
        <span class="control-label">Plane Scale</span>
        <span class="control-value" id="planeScale">0.3m</span>
      </div>
      <div class="control-row">
        <span class="control-label">DOPE 6D Pose</span>
        <span
          class="control-value"
          id="dopeStatus"
          style="color: var(--text-muted)"
          >Waiting...</span
        >
      </div>
      <div class="control-row">
        <span class="control-label">Tool Position</span>
        <span class="control-value" id="toolPosition" style="font-size: 0.75em"
          >--</span
        >
      </div>
      <div class="button-group">
        <button class="btn btn-primary" id="startBtn">Start Streams</button>
        <button class="btn btn-secondary" id="resetBtn">Reset View</button>
      </div>
      <div class="button-group" style="margin-top: 10px">
        <button
          class="btn btn-secondary"
          id="reloadCamsBtn"
          style="width: 100%"
        >
          Reload Cameras
        </button>
      </div>
    </div>

    <!-- Camera list -->
    <div class="camera-panel">
      <div class="panel-title">Camera Views</div>
      <div id="cameraList"></div>
    </div>

    <!-- Three.js and OrbitControls from CDN -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
      import { MTLLoader } from "three/addons/loaders/MTLLoader.js";

      // Color palette for cameras
      const CAMERA_COLORS = [
        0x00d4ff, // cyan
        0xff00aa, // magenta
        0x00ff88, // green
        0xffaa00, // orange
        0xff5555, // red
        0x55ff55, // lime
        0x5555ff, // blue
        0xffff55, // yellow
      ];

      // Scene state
      let scene, camera, renderer, controls;
      let cameraPlanes = {};
      let cameraFrustums = {};
      let calibrationData = {};
      let availableCameras = [];
      let streaming = false;
      let streamIntervals = {};
      let frameCount = 0;
      let lastFpsTime = performance.now();

      // eScrewDriver model reference for real-time pose updates
      let eScrewDriverModel = null;
      let eScrewDriverCentroid = new THREE.Vector3(0, 0, 0); // Model's centroid offset from origin
      let posePollingInterval = null;

      // Camera ID for DOPE detection (coordinate transform reference)
      const DOPE_CAMERA_ID = "142122070087";

      // DOM elements
      const container = document.getElementById("canvas-container");
      const loadingOverlay = document.getElementById("loading");
      const statusDot = document.getElementById("statusDot");
      const statusText = document.getElementById("statusText");
      const cameraCountEl = document.getElementById("cameraCount");
      const frameRate = document.getElementById("frameRate");
      const cameraListEl = document.getElementById("cameraList");
      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");
      const reloadCamsBtn = document.getElementById("reloadCamsBtn");

      // Initialize Three.js scene
      function initScene() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Add fog for depth
        scene.fog = new THREE.Fog(0xffffff, 5, 20);

        // Camera
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        // Position to see the multi-camera setup from above and side
        camera.position.set(1.5, 1.5, 2.5);
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 0.5;
        controls.maxDistance = 15;
        controls.target.set(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Grid helper at global coordinate origin (0,0,0)
        const gridHelper = new THREE.GridHelper(3, 15, 0x888888, 0xcccccc);
        gridHelper.position.set(-1, -1, -2); // Positioned at world origin
        scene.add(gridHelper);

        // Handle resize
        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Load calibration data
      async function loadCalibration() {
        try {
          const response = await fetch("/api/calibration");
          calibrationData = await response.json();
          console.log("Calibration loaded:", Object.keys(calibrationData));
          return calibrationData;
        } catch (error) {
          console.error("Failed to load calibration:", error);
          return {};
        }
      }

      // Load GLB scene - origin is at camera 141722079467, 138422075916
      async function loadGLBScene() {
        const loader = new GLTFLoader();
        const glbPath = "videos/VGGT_demo/calib_david_glbscene_50.2.glb";

        //  "videos/VGGT_demo/calib_glbscene_24.2_All_maskbFalse_maskwFalse_camTrue_skyFalse_predDepthmap_and_Camera_Branch.glb";
        //"videos/VGGT_demo/calib_glbscene_48.1_All_maskbFalse_maskwFalse_camTrue_skyFalse_predDepthmap_and_Camera_Branch.glb";
        //"videos/VGGT_demo/glbscene_97.3_All_maskbFalse_maskwFalse_camTrue_skyFalse_predDepthmap_and_Camera_Branch.glb";
        //"videos/VGGT_demo/glbscene_48.1_All_maskbFalse_maskwFalse_camTrue_skyFalse_predDepthmap_and_Camera_Branch.glb";
        // "/videos/VGGT_demo/glbscene_50_All_maskbFalse_maskwFalse_camTrue_skyFalse_predDepthmap_and_Camera_Branch.glb";
        const glbOriginCameraId = "135122071615";

        return new Promise((resolve, reject) => {
          loader.load(
            glbPath,
            (gltf) => {
              console.log("GLB scene loaded successfully");
              const model = gltf.scene;

              // The GLB's origin is at camera 141722079467's viewpoint
              // We need to position the GLB at that camera's world position
              const calibration = calibrationData[glbOriginCameraId];
              if (calibration && calibration.extrinsics) {
                const ext = calibration.extrinsics;

                // Extract translation and rotation from camera extrinsics
                const t = [ext[0][3], ext[1][3], ext[2][3]];
                const R = [
                  [ext[0][0], ext[0][1], ext[0][2]],
                  [ext[1][0], ext[1][1], ext[1][2]],
                  [ext[2][0], ext[2][1], ext[2][2]],
                ];

                // Convert from OpenCV to Three.js coordinate system
                const position = new THREE.Vector3(t[0], -t[1], -t[2]);

                // Build rotation matrix in Three.js coordinates
                const rotMatrix = new THREE.Matrix4();
                rotMatrix.set(
                  R[0][0],
                  -R[0][1],
                  -R[0][2],
                  0,
                  -R[1][0],
                  R[1][1],
                  R[1][2],
                  0,
                  -R[2][0],
                  R[2][1],
                  R[2][2],
                  0,
                  0,
                  0,
                  0,
                  1
                );

                const quaternion = new THREE.Quaternion();
                quaternion.setFromRotationMatrix(rotMatrix);

                // Rotate 180 degrees around Y axis to face correct direction
                const flip180 = new THREE.Quaternion();
                flip180.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
                quaternion.multiply(flip180);

                // Apply transformation to model
                model.position.copy(position);
                model.quaternion.copy(quaternion);

                // Scale if needed (uncomment if GLB is in mm instead of meters)
                model.scale.set(1.4, 1.4, 1.4);

                console.log(
                  `GLB model positioned at camera ${glbOriginCameraId}:`,
                  position.toArray().map((v) => v.toFixed(3))
                );
              } else {
                console.warn("Calibration not found for GLB origin camera");
                model.position.set(0, 0, 0);
              }

              scene.add(model);
              console.log("GLB model added to scene");
              resolve(model);
            },
            (progress) => {
              const percent = (progress.loaded / progress.total) * 100;
              console.log(`Loading GLB: ${percent.toFixed(1)}%`);
            },
            (error) => {
              console.error("Error loading GLB:", error);
              reject(error);
            }
          );
        });
      }

      // Load OBJ model with MTL material
      async function loadOBJModel() {
        const basePath = "videos/scanned_objects/e-screw-driver/";
        const objFileName = "eScrewDriver.obj";
        const mtlFileName = "eScrewDriver.mtl";

        console.log("Starting OBJ model load...");
        console.log("Base path:", basePath);
        console.log("OBJ file:", objFileName);
        console.log("MTL file:", mtlFileName);

        return new Promise((resolve, reject) => {
          const mtlLoader = new MTLLoader();
          mtlLoader.setPath(basePath);

          mtlLoader.load(
            mtlFileName,
            (materials) => {
              materials.preload();
              console.log("MTL materials loaded");

              const objLoader = new OBJLoader();
              objLoader.setMaterials(materials);

              objLoader.load(
                basePath + objFileName,
                (object) => {
                  console.log("OBJ model loaded successfully");

                  // Apply scale
                  object.scale.set(1, 1, 1);

                  // Calculate bounding box to find centroid offset
                  const boundingBox = new THREE.Box3().setFromObject(object);
                  const center = new THREE.Vector3();
                  boundingBox.getCenter(center);

                  // Store the centroid offset (in model's local coordinates)
                  eScrewDriverCentroid.copy(center);
                  console.log(
                    "Model centroid offset:",
                    center.toArray().map((v) => v.toFixed(4))
                  );

                  // Initially hidden until we get a pose
                  object.visible = false;
                  object.position.set(0, 0, 0);

                  // Enable shadows if needed
                  object.traverse((child) => {
                    if (child instanceof THREE.Mesh) {
                      child.castShadow = true;
                      child.receiveShadow = true;
                      console.log("Mesh found:", child.name || "unnamed");
                    }
                  });

                  scene.add(object);

                  // Store reference for pose updates
                  eScrewDriverModel = object;

                  console.log(
                    "OBJ model added to scene (hidden until DOPE detection)"
                  );
                  resolve(object);
                },
                (progress) => {
                  const percent = (progress.loaded / progress.total) * 100;
                  console.log(`Loading OBJ: ${percent.toFixed(1)}%`);
                },
                (error) => {
                  console.error(
                    "Error loading OBJ file:",
                    basePath + objFileName
                  );
                  console.error("OBJ Error details:", error);
                  console.error(
                    "Make sure the file exists at:",
                    window.location.origin + "/" + basePath + objFileName
                  );
                  reject(error);
                }
              );
            },
            (progress) => {
              console.log("Loading MTL...", progress);
            },
            (error) => {
              console.error("Error loading MTL file:", basePath + mtlFileName);
              console.error("MTL Error details:", error);
              console.error(
                "Make sure the file exists at:",
                window.location.origin + "/" + basePath + mtlFileName
              );
              reject(error);
            }
          );
        });
      }

      // DOM elements for DOPE status
      const dopeStatusEl = document.getElementById("dopeStatus");
      const toolPositionEl = document.getElementById("toolPosition");

      // Fetch and update tool pose from DOPE detection
      async function updateToolPose() {
        if (!eScrewDriverModel) return;

        try {
          const response = await fetch("/api/tool/pose");
          const poseData = await response.json();

          if (poseData.detected) {
            // Get the DOPE camera calibration for coordinate transform
            const camCalib = calibrationData[DOPE_CAMERA_ID];
            if (!camCalib || !camCalib.extrinsics) {
              console.warn("No calibration for DOPE camera");
              return;
            }

            // Extract camera extrinsics (camera to world transform)
            const ext = camCalib.extrinsics;
            const camR = new THREE.Matrix4();
            camR.set(
              ext[0][0],
              -ext[0][1],
              -ext[0][2],
              0,
              -ext[1][0],
              ext[1][1],
              ext[1][2],
              0,
              -ext[2][0],
              ext[2][1],
              ext[2][2],
              0,
              0,
              0,
              0,
              1
            );
            const camPos = new THREE.Vector3(ext[0][3], -ext[1][3], -ext[2][3]);
            const camQuat = new THREE.Quaternion().setFromRotationMatrix(camR);

            // Object pose from DOPE (in camera coordinates)
            const objLocation = poseData.location; // [x, y, z] in meters
            const objQuaternion = poseData.quaternion; // [x, y, z, w]

            // Convert object position from camera to world coordinates
            // In OpenCV camera: X-right, Y-down, Z-forward
            // In Three.js: X-right, Y-up, Z-backward
            const objLocalPos = new THREE.Vector3(
              objLocation[0],
              -objLocation[1], // Flip Y
              -objLocation[2] // Flip Z
            );

            // Transform to world coordinates
            objLocalPos.applyQuaternion(camQuat);
            const worldPos = objLocalPos.add(camPos);

            // Convert object rotation from OpenCV to Three.js
            // Quaternion from DOPE is in camera frame
            const objQuat = new THREE.Quaternion(
              objQuaternion[0],
              -objQuaternion[1], // Flip Y
              -objQuaternion[2], // Flip Z
              objQuaternion[3]
            );

            // Combine with camera rotation
            const worldQuat = camQuat.clone().multiply(objQuat);

            // Flip the object 180 degrees around Y axis (in XZ plane)
            const flipY = new THREE.Quaternion();
            flipY.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI);
            const flipZ = new THREE.Quaternion();
            flipZ.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
            const finalQuat = worldQuat.clone().multiply(flipY).multiply(flipZ);

            // Apply pose to model's centroid (not origin)
            // The DOPE pose specifies where the centroid should be
            // We need to offset the model position so its centroid ends up there

            // Rotate the centroid offset by the final rotation (including flip)
            const rotatedCentroid = eScrewDriverCentroid
              .clone()
              .applyQuaternion(finalQuat);

            // Offset position so centroid is at the detected pose
            const modelPos = worldPos.clone().sub(rotatedCentroid);

            // Apply to model - always visible once detected
            eScrewDriverModel.position.copy(modelPos);
            eScrewDriverModel.quaternion.copy(finalQuat);
            eScrewDriverModel.visible = true;

            // Update status indicators based on fresh or cached pose
            statusDot.classList.add("active");
            if (poseData.fresh) {
              statusText.textContent = "Tool Detected";
              dopeStatusEl.textContent = "DETECTED";
              dopeStatusEl.style.color = "var(--accent-green)";
            } else {
              statusText.textContent = "Tool (cached)";
              dopeStatusEl.textContent = "CACHED";
              dopeStatusEl.style.color = "var(--accent-cyan)";
            }

            // Show position in UI
            toolPositionEl.textContent = `${worldPos.x.toFixed(
              2
            )}, ${worldPos.y.toFixed(2)}, ${worldPos.z.toFixed(2)}m`;
          } else {
            // No detection yet - keep model hidden until first detection
            // Model will remain visible at last position once detected
            dopeStatusEl.textContent = "Searching...";
            dopeStatusEl.style.color = "var(--accent-cyan)";
            toolPositionEl.textContent = "--";

            if (!streaming) {
              statusText.textContent = "Ready";
            } else {
              statusText.textContent = "Streaming";
            }
          }
        } catch (error) {
          // Silently handle errors to avoid console spam
          dopeStatusEl.textContent = "Error";
          dopeStatusEl.style.color = "var(--accent-magenta)";
        }
      }

      // Start polling for tool pose updates
      function startPosePolling() {
        if (posePollingInterval) return;
        posePollingInterval = setInterval(updateToolPose, 100); // Poll every 100ms
        console.log("[Pose] Started polling for tool pose");
      }

      // Stop polling for tool pose updates
      function stopPosePolling() {
        if (posePollingInterval) {
          clearInterval(posePollingInterval);
          posePollingInterval = null;
          console.log("[Pose] Stopped polling for tool pose");
        }
        // Keep the model visible at last known position (don't hide it)
        // Just update status indicator
        dopeStatusEl.textContent = "Paused";
        dopeStatusEl.style.color = "var(--text-muted)";
      }

      // Load available cameras
      async function loadCameras() {
        try {
          const response = await fetch("/api/cameras");
          return await response.json();
        } catch (error) {
          console.error("Failed to load cameras:", error);
          return [];
        }
      }

      // Create camera plane with video texture
      function createCameraPlane(cameraId, colorIndex) {
        const planeWidth = 0.3; // 30cm in scene units (meters)
        const planeHeight = 0.17; // Maintain 16:9 aspect ratio

        // Create plane geometry
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

        // Create canvas for texture
        const canvas = document.createElement("canvas");
        canvas.width = 320;
        canvas.height = 180;
        const ctx = canvas.getContext("2d");

        // Initial placeholder
        ctx.fillStyle = "#1a1a25";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#555566";
        ctx.font = "14px JetBrains Mono";
        ctx.textAlign = "center";
        ctx.fillText(`Camera ${cameraId}`, canvas.width / 2, canvas.height / 2);

        // Create texture
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        // Material
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
        });

        // Mesh
        const plane = new THREE.Mesh(geometry, material);
        plane.userData = {
          cameraId: cameraId,
          canvas: canvas,
          ctx: ctx,
          texture: texture,
        };

        // Add border frame
        const borderGeometry = new THREE.EdgesGeometry(geometry);
        const borderMaterial = new THREE.LineBasicMaterial({
          color: CAMERA_COLORS[colorIndex % CAMERA_COLORS.length],
        });
        const border = new THREE.LineSegments(borderGeometry, borderMaterial);
        plane.add(border);

        return plane;
      }

      // Create camera frustum visualization
      function createCameraFrustum(cameraId, colorIndex) {
        const color = CAMERA_COLORS[colorIndex % CAMERA_COLORS.length];
        const frustumLength = 0.15;
        const frustumWidth = 0.08;
        const frustumHeight = 0.045;

        // Create frustum lines - pointing along -Z (Three.js camera convention)
        const points = [
          // Origin
          new THREE.Vector3(0, 0, 0),
          // Four corners of far plane (negative Z direction)
          new THREE.Vector3(-frustumWidth, -frustumHeight, -frustumLength),
          new THREE.Vector3(frustumWidth, -frustumHeight, -frustumLength),
          new THREE.Vector3(frustumWidth, frustumHeight, -frustumLength),
          new THREE.Vector3(-frustumWidth, frustumHeight, -frustumLength),
        ];

        const lineGeometry = new THREE.BufferGeometry();
        const linePositions = [
          // Lines from origin to corners
          0,
          0,
          0,
          points[1].x,
          points[1].y,
          points[1].z,
          0,
          0,
          0,
          points[2].x,
          points[2].y,
          points[2].z,
          0,
          0,
          0,
          points[3].x,
          points[3].y,
          points[3].z,
          0,
          0,
          0,
          points[4].x,
          points[4].y,
          points[4].z,
          // Rectangle at far plane
          points[1].x,
          points[1].y,
          points[1].z,
          points[2].x,
          points[2].y,
          points[2].z,
          points[2].x,
          points[2].y,
          points[2].z,
          points[3].x,
          points[3].y,
          points[3].z,
          points[3].x,
          points[3].y,
          points[3].z,
          points[4].x,
          points[4].y,
          points[4].z,
          points[4].x,
          points[4].y,
          points[4].z,
          points[1].x,
          points[1].y,
          points[1].z,
        ];

        lineGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(linePositions, 3)
        );
        const lineMaterial = new THREE.LineBasicMaterial({
          color: color,
          opacity: 0.7,
          transparent: true,
        });
        const frustum = new THREE.LineSegments(lineGeometry, lineMaterial);

        // Camera body (small box)
        const bodyGeometry = new THREE.BoxGeometry(0.04, 0.03, 0.02);
        const bodyMaterial = new THREE.MeshBasicMaterial({ color: color });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.z = 0.01;
        frustum.add(body);

        return frustum;
      }

      // Position camera in scene based on extrinsics
      function positionCamera(cameraId, plane, frustum) {
        const calibration = calibrationData[cameraId];
        if (!calibration || !calibration.extrinsics) {
          console.warn(`No extrinsics for camera ${cameraId}`);
          return;
        }

        const ext = calibration.extrinsics;

        // Extract rotation matrix R and translation vector t from 4x4 matrix
        // The extrinsics are camera-to-world transforms
        const R = [
          [ext[0][0], ext[0][1], ext[0][2]],
          [ext[1][0], ext[1][1], ext[1][2]],
          [ext[2][0], ext[2][1], ext[2][2]],
        ];
        const t = [ext[0][3], ext[1][3], ext[2][3]];

        // Convert from OpenCV to Three.js coordinate system:
        // OpenCV: X-right, Y-down, Z-forward
        // Three.js: X-right, Y-up, Z-backward
        const position = new THREE.Vector3(
          t[0],
          -t[1], // Flip Y
          -t[2] // Flip Z
        );

        // Use rotation from extrinsics
        // Convert rotation: R' = F * R * F where F = diag(1,-1,-1)
        const rotMatrix = new THREE.Matrix4();
        rotMatrix.set(
          R[0][0],
          -R[0][1],
          -R[0][2],
          0,
          -R[1][0],
          R[1][1],
          R[1][2],
          0,
          -R[2][0],
          R[2][1],
          R[2][2],
          0,
          0,
          0,
          0,
          1
        );
        const quaternion = new THREE.Quaternion();
        quaternion.setFromRotationMatrix(rotMatrix);

        // Position the frustum at camera location
        frustum.position.copy(position);
        frustum.quaternion.copy(quaternion);

        // Position plane in front of camera (along -Z in camera local space)
        const planeOffset = 0.15;
        const lookDir = new THREE.Vector3(0, 0, -1);
        lookDir.applyQuaternion(quaternion);

        plane.position.copy(position).addScaledVector(lookDir, planeOffset);
        plane.quaternion.copy(quaternion);

        console.log(
          `Camera ${cameraId} (#${calibration.number}) pos:`,
          position.toArray().map((v) => v.toFixed(3))
        );
      }

      // Reload all camera positions with current settings
      function reloadCameraPositions() {
        availableCameras.forEach((cameraId) => {
          const plane = cameraPlanes[cameraId];
          const frustum = cameraFrustums[cameraId];
          if (plane && frustum) {
            positionCamera(cameraId, plane, frustum);
          }
        });

        console.log("Reloaded camera positions");
      }

      // Create UI for camera list
      function createCameraListUI(cameras) {
        cameraListEl.innerHTML = "";

        cameras.forEach((camId, index) => {
          const item = document.createElement("div");
          item.className = "camera-item";
          item.dataset.cameraId = camId;

          const color = CAMERA_COLORS[index % CAMERA_COLORS.length];
          const calibration = calibrationData[camId];
          const camNumber = calibration ? calibration.number : index + 1;
          const isMaster = calibration && calibration.master;
          const hasYolo = calibration && calibration.yolo_enabled;

          let badges = "";
          if (isMaster) badges += " (Master)";
          if (hasYolo)
            badges +=
              ' <span style="color:#00ff88;font-weight:600;">YOLO</span>';

          item.innerHTML = `
            <div class="camera-color" style="background: #${color
              .toString(16)
              .padStart(6, "0")}"></div>
            <div class="camera-info">
              <div class="camera-id">${camId}</div>
              <div class="camera-number">Camera #${camNumber}${badges}</div>
            </div>
          `;

          item.addEventListener("click", () => focusOnCamera(camId));
          cameraListEl.appendChild(item);
        });
      }

      // Focus view on specific camera
      function focusOnCamera(cameraId) {
        const plane = cameraPlanes[cameraId];
        if (!plane) return;

        // Animate camera to look at plane
        const targetPos = plane.position.clone();

        // Calculate good viewing position
        const direction = new THREE.Vector3(0, 0, 1);
        direction.applyQuaternion(plane.quaternion);

        const viewPos = targetPos.clone().add(direction.multiplyScalar(1.5));
        viewPos.y += 0.5;

        // Update controls target
        controls.target.copy(targetPos);
        camera.position.copy(viewPos);

        // Update selected state in UI
        document.querySelectorAll(".camera-item").forEach((item) => {
          item.classList.toggle("selected", item.dataset.cameraId === cameraId);
        });
      }

      // Start streaming frames
      async function startStreaming() {
        if (streaming) return;

        // Tell the server to start processing frames
        try {
          const response = await fetch("/api/stream/start", { method: "POST" });
          const result = await response.json();
          console.log("[Stream] Server started:", result);
        } catch (error) {
          console.error("[Stream] Failed to start server streaming:", error);
          return;
        }

        streaming = true;

        // Start pose polling for real-time tool position updates
        startPosePolling();

        Object.keys(cameraPlanes).forEach((cameraId) => {
          const plane = cameraPlanes[cameraId];
          const { canvas, ctx, texture } = plane.userData;

          // Create image element for loading frames
          const img = new Image();
          img.crossOrigin = "anonymous";

          const updateFrame = () => {
            if (!streaming) return;

            // Add timestamp to avoid caching
            img.src = `/api/frame/${cameraId}?t=${Date.now()}`;
          };

          img.onload = () => {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            texture.needsUpdate = true;
            frameCount++;

            if (streaming) {
              // Request next frame
              setTimeout(updateFrame, 66); // ~15 FPS
            }
          };

          img.onerror = () => {
            if (streaming) {
              setTimeout(updateFrame, 500);
            }
          };

          // Start loading frames
          updateFrame();
        });

        startBtn.textContent = "Stop Streams";
        statusDot.classList.add("active");
        statusText.textContent = "Streaming";
      }

      // Stop streaming
      async function stopStreaming() {
        streaming = false;

        // Stop pose polling
        stopPosePolling();

        // Tell the server to stop processing frames
        try {
          const response = await fetch("/api/stream/stop", { method: "POST" });
          const result = await response.json();
          console.log("[Stream] Server stopped:", result);
        } catch (error) {
          console.error("[Stream] Failed to stop server streaming:", error);
        }

        startBtn.textContent = "Start Streams";
        statusDot.classList.remove("active");
        statusText.textContent = "Paused";
      }

      // Reset view
      function resetView() {
        camera.position.set(1.5, 1.5, 2.5);
        controls.target.set(0, 0, 0);
        controls.update();

        document.querySelectorAll(".camera-item").forEach((item) => {
          item.classList.remove("selected");
        });
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        controls.update();
        renderer.render(scene, camera);

        // Update FPS counter
        const now = performance.now();
        if (now - lastFpsTime >= 1000) {
          frameRate.textContent = `${frameCount} fps`;
          frameCount = 0;
          lastFpsTime = now;
        }
      }

      // Initialize everything
      async function init() {
        // Initialize Three.js
        initScene();

        // Load calibration first (needed for GLB positioning)
        await loadCalibration();
        availableCameras = await loadCameras();

        console.log("Available cameras:", availableCameras);

        // Load GLB scene model (after calibration so we can position it)
        try {
          await loadGLBScene();
        } catch (error) {
          console.error("Failed to load GLB scene, continuing anyway:", error);
        }

        // Load OBJ model (e-screw-driver)
        try {
          await loadOBJModel();
        } catch (error) {
          console.error("Failed to load OBJ model, continuing anyway:", error);
        }

        // Create camera planes and frustums
        availableCameras.forEach((cameraId, index) => {
          // Create plane with video texture
          const plane = createCameraPlane(cameraId, index);
          cameraPlanes[cameraId] = plane;
          scene.add(plane);

          // Create frustum visualization
          const frustum = createCameraFrustum(cameraId, index);
          cameraFrustums[cameraId] = frustum;
          scene.add(frustum);

          // Position based on extrinsics
          positionCamera(cameraId, plane, frustum, false);
        });

        // Update UI
        cameraCountEl.textContent = availableCameras.length.toString();
        createCameraListUI(availableCameras);

        // Event listeners
        startBtn.addEventListener("click", () => {
          if (streaming) {
            stopStreaming();
          } else {
            startStreaming();
          }
        });

        resetBtn.addEventListener("click", resetView);

        // Button event listener for camera repositioning
        reloadCamsBtn.addEventListener("click", reloadCameraPositions);

        // Hide loading overlay
        loadingOverlay.classList.add("hidden");
        statusText.textContent = "Ready";

        // Start animation
        animate();
      }

      // Start
      init().catch(console.error);
    </script>
  </body>
</html>
